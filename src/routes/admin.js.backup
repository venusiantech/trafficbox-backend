const express = require("express");
const { requireRole } = require("../middleware/auth");
const Campaign = require("../models/Campaign");
const User = require("../models/User");
const Subscription = require("../models/Subscription");

const router = express.Router();

// Admin Dashboard - Overview Stats
router.get("/dashboard", requireRole("admin"), async (req, res) => {
  try {
    const [
      totalUsers,
      totalCampaigns,
      activeCampaigns,
      pausedCampaigns,
      sparkTrafficCampaigns,
      nineHitsCampaigns,
      totalSubscriptions,
      activeSubscriptions,
      subscriptionStats,
      recentUsers,
      recentCampaigns,
    ] = await Promise.all([
      User.countDocuments(),
      Campaign.countDocuments(),
      Campaign.countDocuments({ state: { $in: ["created", "ok", "running"] } }),
      Campaign.countDocuments({ state: "paused" }),
      Campaign.countDocuments({ spark_traffic_project_id: { $ne: null } }),
      Campaign.countDocuments({ nine_hits_campaign_id: { $ne: null } }),
      Subscription.countDocuments(),
      Subscription.countDocuments({ status: { $in: ["active", "trialing"] } }),
      Subscription.aggregate([
        {
          $group: {
            _id: null,
            totalVisitsUsed: { $sum: "$visitsUsed" },
            totalVisitsIncluded: { $sum: "$visitsIncluded" },
            avgVisitsUsed: { $avg: "$visitsUsed" },
          },
        },
      ]),
      User.find({})
        .sort({ createdAt: -1 })
        .limit(10)
        .select("email firstName lastName createdAt"),
      Campaign.find({})
        .sort({ createdAt: -1 })
        .limit(10)
        .populate("user", "email firstName lastName"),
    ]);

    res.json({
      ok: true,
      dashboard: {
        stats: {
          users: {
            total: totalUsers,
          },
          campaigns: {
            total: totalCampaigns,
            active: activeCampaigns,
            paused: pausedCampaigns,
            sparkTraffic: sparkTrafficCampaigns,
            nineHits: nineHitsCampaigns,
          },
          subscriptions: {
            total: totalSubscriptions,
            active: activeSubscriptions,
            totalVisitsUsed: subscriptionStats[0]?.totalVisitsUsed || 0,
            totalVisitsIncluded: subscriptionStats[0]?.totalVisitsIncluded || 0,
            avgVisitsUsed: Math.round(subscriptionStats[0]?.avgVisitsUsed || 0),
            utilizationRate: subscriptionStats[0]?.totalVisitsIncluded
              ? Math.round(
                  (subscriptionStats[0].totalVisitsUsed /
                    subscriptionStats[0].totalVisitsIncluded) *
                    100
                )
              : 0,
          },
        },
        recent: {
          users: recentUsers,
          campaigns: recentCampaigns,
        },
      },
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Get All Users with Details
router.get("/users", requireRole("admin"), async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 20;
    const skip = (page - 1) * limit;

    const [users, totalUsers] = await Promise.all([
      User.find({})
        .select("-password")
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(limit),
      User.countDocuments(),
    ]);

    // Get campaign counts and subscription info for each user
    const usersWithCampaigns = await Promise.all(
      users.map(async (user) => {
        const campaignCount = await Campaign.countDocuments({ user: user._id });
        const activeCampaigns = await Campaign.countDocuments({
          user: user._id,
          state: { $in: ["created", "ok", "running"] },
        });
        const subscription = await Subscription.findOne({ user: user._id }).select(
          "planName status visitsUsed visitsIncluded"
        );
        return {
          ...user.toObject(),
          campaignStats: {
            total: campaignCount,
            active: activeCampaigns,
          },
          subscription: subscription
            ? {
                planName: subscription.planName,
                status: subscription.status,
                visitsUsed: subscription.visitsUsed,
                visitsIncluded: subscription.visitsIncluded,
                availableVisits: subscription.visitsIncluded - subscription.visitsUsed,
              }
            : null,
        };
      })
    );

    res.json({
      ok: true,
      users: usersWithCampaigns,
      pagination: {
        currentPage: page,
        totalPages: Math.ceil(totalUsers / limit),
        totalUsers,
        hasNext: page * limit < totalUsers,
        hasPrev: page > 1,
      },
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Get All Campaigns with Details
router.get("/campaigns", requireRole("admin"), async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 20;
    const skip = (page - 1) * limit;

    const vendor = req.query.vendor; // Filter by vendor
    const state = req.query.state; // Filter by state

    let filter = {};
    if (vendor === "sparkTraffic")
      filter.spark_traffic_project_id = { $ne: null };
    if (vendor === "nineHits") filter.nine_hits_campaign_id = { $ne: null };
    if (state) filter.state = state;

    const [campaigns, totalCampaigns] = await Promise.all([
      Campaign.find(filter)
        .populate("user", "email firstName lastName")
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(limit),
      Campaign.countDocuments(filter),
    ]);

    res.json({
      ok: true,
      campaigns,
      pagination: {
        currentPage: page,
        totalPages: Math.ceil(totalCampaigns / limit),
        totalCampaigns,
        hasNext: page * limit < totalCampaigns,
        hasPrev: page > 1,
      },
      filters: { vendor, state },
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Get User Details with All Campaigns
router.get("/users/:userId", requireRole("admin"), async (req, res) => {
  try {
    const user = await User.findById(req.params.userId).select("-password");
    if (!user) return res.status(404).json({ error: "User not found" });

    const campaigns = await Campaign.find({ user: req.params.userId }).sort({
      createdAt: -1,
    });

    const campaignStats = {
      total: campaigns.length,
      active: campaigns.filter((c) =>
        ["created", "ok", "running"].includes(c.state)
      ).length,
      paused: campaigns.filter((c) => c.state === "paused").length,
      sparkTraffic: campaigns.filter((c) => c.spark_traffic_project_id).length,
      nineHits: campaigns.filter((c) => c.nine_hits_campaign_id).length,
    };

    res.json({
      ok: true,
      user: user.toObject(),
      campaigns,
      campaignStats,
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// REMOVED: Credit management endpoint - System now uses subscription-based visit tracking
// Use subscription management endpoints instead (/api/admin/subscriptions)

// Transfer Alpha Campaign from one user to another (MUST be before the pause/resume route)
router.post(
  "/campaigns/:campaignId/transfer",
  requireRole("admin"),
  async (req, res) => {
    try {
      const { campaignId } = req.params;
      const { targetUserId, reason } = req.body;

      // Validate required fields
      if (!targetUserId) {
        return res.status(400).json({
          status: "error",
          message: "Target user ID is required",
        });
      }

      // Find the campaign
      const campaign = await Campaign.findById(campaignId).populate(
        "user",
        "email firstName lastName"
      );
      if (!campaign) {
        return res.status(404).json({
          status: "error",
          message: "Campaign not found",
        });
      }

      // Check if it's an Alpha campaign
      if (!campaign.spark_traffic_project_id) {
        return res.status(400).json({
          status: "error",
          message: "Only Alpha (SparkTraffic) campaigns can be transferred",
        });
      }

      // Find target user
      const targetUser = await User.findById(targetUserId).select(
        "email firstName lastName"
      );
      if (!targetUser) {
        return res.status(404).json({
          status: "error",
          message: "Target user not found",
        });
      }

      // Find source user
      const sourceUser = await User.findById(campaign.user).select(
        "email firstName lastName"
      );

      // Prevent transferring to the same user
      if (campaign.user.toString() === targetUserId) {
        return res.status(400).json({
          status: "error",
          message: "Campaign is already owned by this user",
        });
      }

      // Store original owner info for logging
      const originalOwner = {
        id: campaign.user._id,
        email: sourceUser.email,
        name: `${sourceUser.firstName} ${sourceUser.lastName}`.trim(),
      };

      // Transfer the campaign
      const oldUserId = campaign.user._id;
      campaign.user = targetUserId;

      // Add transfer metadata
      if (!campaign.transfer_history) {
        campaign.transfer_history = [];
      }

      campaign.transfer_history.push({
        from_user: oldUserId,
        to_user: targetUserId,
        transferred_by: req.user.id,
        transferred_at: new Date(),
        reason: reason || "Admin transfer",
        admin_email: req.user.email,
      });

      await campaign.save();

      // Populate the new owner details
      await campaign.populate(
        "user",
        "email firstName lastName"
      );

      res.json({
        status: "success",
        message: "Alpha campaign transferred successfully",
        transfer: {
          campaignId: campaign._id,
          campaignTitle: campaign.title,
          sparkTrafficProjectId: campaign.spark_traffic_project_id,
          from: {
            userId: originalOwner.id,
            email: originalOwner.email,
            name: originalOwner.name,
          },
          to: {
            userId: targetUser._id,
            email: targetUser.email,
            name: `${targetUser.firstName} ${targetUser.lastName}`.trim(),
          },
          transferredBy: {
            adminId: req.user.id,
            adminEmail: req.user.email,
          },
          transferredAt: new Date(),
          reason: reason || "Admin transfer",
        },
        campaign: campaign,
      });
    } catch (error) {
      console.error("Error transferring campaign:", error);
      res.status(500).json({
        status: "error",
        message: "Internal server error",
        error: error.message,
      });
    }
  }
);

// Force Pause/Resume Campaign
router.post(
  "/campaigns/:campaignId/:action",
  requireRole("admin"),
  async (req, res) => {
    try {
      const { campaignId, action } = req.params;

      if (!["pause", "resume"].includes(action)) {
        return res
          .status(400)
          .json({ error: "Invalid action. Use 'pause' or 'resume'" });
      }

      const campaign = await Campaign.findById(campaignId).populate(
        "user",
        "email firstName lastName"
      );
      if (!campaign)
        return res.status(404).json({ error: "Campaign not found" });

      let vendorResp = null;

      // Handle SparkTraffic campaigns
      if (campaign.spark_traffic_project_id) {
        try {
          const axios = require("axios");
          const API_KEY = process.env.SPARKTRAFFIC_API_KEY?.trim();

          vendorResp = await axios.post(
            "https://v2.sparktraffic.com/edit-website-traffic-project",
            {
              id: campaign.spark_traffic_project_id,
              speed: action === "pause" ? 0 : 200,
              size: "eco",
            },
            {
              headers: {
                "Content-Type": "application/json",
                API_KEY,
              },
            }
          );
        } catch (err) {
          vendorResp = { error: err.message };
        }
      }

      // Handle 9Hits campaigns
      if (campaign.nine_hits_campaign_id) {
        try {
          const nine = require("../services/nineHits");
          if (action === "pause") {
            vendorResp = await nine.sitePause({
              id: campaign.nine_hits_campaign_id,
            });
          } else {
            vendorResp = await nine.siteUpdate({
              id: campaign.nine_hits_campaign_id,
              userState: "running",
            });
          }
        } catch (err) {
          vendorResp = { error: err.message };
        }
      }

      // Update campaign state
      campaign.state = action === "pause" ? "paused" : "ok";
      if (action === "resume") campaign.userState = "running";
      await campaign.save();

      res.json({
        ok: true,
        message: `Campaign ${action}d successfully by admin`,
        campaign,
        vendorResp:
          vendorResp && vendorResp.data ? vendorResp.data : vendorResp,
      });
    } catch (err) {
      res.status(500).json({ error: err.message });
    }
  }
);

// Delete Campaign (Admin Override)
router.delete(
  "/campaigns/:campaignId",
  requireRole("admin"),
  async (req, res) => {
    try {
      const campaign = await Campaign.findById(req.params.campaignId).populate(
        "user",
        "email firstName lastName"
      );
      if (!campaign)
        return res.status(404).json({ error: "Campaign not found" });

      // Try to delete from vendor
      let vendorResp = null;
      if (campaign.nine_hits_campaign_id) {
        try {
          const nine = require("../services/nineHits");
          vendorResp = await nine.siteDelete({
            id: campaign.nine_hits_campaign_id,
          });
        } catch (err) {
          vendorResp = { error: err.message };
        }
      }

      await campaign.deleteOne();

      res.json({
        ok: true,
        message: "Campaign deleted successfully by admin",
        deletedCampaign: campaign,
        vendorResp,
      });
    } catch (err) {
      res.status(500).json({ error: err.message });
    }
  }
);

// System Analytics
router.get("/analytics", requireRole("admin"), async (req, res) => {
  try {
    const days = parseInt(req.query.days) || 30;
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - days);

    const [
      userGrowth,
      campaignGrowth,
      vendorDistribution,
      stateDistribution,
      creditUsage,
    ] = await Promise.all([
      // User registrations over time
      User.aggregate([
        { $match: { createdAt: { $gte: startDate } } },
        {
          $group: {
            _id: { $dateToString: { format: "%Y-%m-%d", date: "$createdAt" } },
            count: { $sum: 1 },
          },
        },
        { $sort: { _id: 1 } },
      ]),

      // Campaign creation over time
      Campaign.aggregate([
        { $match: { createdAt: { $gte: startDate } } },
        {
          $group: {
            _id: { $dateToString: { format: "%Y-%m-%d", date: "$createdAt" } },
            count: { $sum: 1 },
          },
        },
        { $sort: { _id: 1 } },
      ]),

      // Vendor distribution
      Campaign.aggregate([
        {
          $group: {
            _id: {
              $cond: {
                if: { $ne: ["$spark_traffic_project_id", null] },
                then: "SparkTraffic",
                else: {
                  $cond: {
                    if: { $ne: ["$nine_hits_campaign_id", null] },
                    then: "9Hits",
                    else: "Unknown",
                  },
                },
              },
            },
            count: { $sum: 1 },
          },
        },
      ]),

      // Campaign state distribution
      Campaign.aggregate([{ $group: { _id: "$state", count: { $sum: 1 } } }]),

      // Subscription usage stats (replaces legacy credit stats)
      Subscription.aggregate([
        {
          $group: {
            _id: null,
            totalVisitsUsed: { $sum: "$visitsUsed" },
            totalVisitsIncluded: { $sum: "$visitsIncluded" },
            avgVisitsUsed: { $avg: "$visitsUsed" },
            avgVisitsIncluded: { $avg: "$visitsIncluded" },
            totalActiveSubscriptions: {
              $sum: {
                $cond: [
                  { $in: ["$status", ["active", "trialing"]] },
                  1,
                  0,
                ],
              },
            },
          },
        },
      ]),
    ]);

    res.json({
      ok: true,
      analytics: {
        period: `${days} days`,
        userGrowth,
        campaignGrowth,
        distributions: {
          vendors: vendorDistribution,
          states: stateDistribution,
        },
        subscriptionUsage: creditUsage[0] || {},
      },
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Search Users and Campaigns
router.get("/search", requireRole("admin"), async (req, res) => {
  try {
    const { q, type = "all" } = req.query;
    if (!q) return res.status(400).json({ error: "Search query required" });

    const results = {};

    if (type === "all" || type === "users") {
      results.users = await User.find({
        $or: [
          { email: { $regex: q, $options: "i" } },
          { firstName: { $regex: q, $options: "i" } },
          { lastName: { $regex: q, $options: "i" } },
        ],
      })
        .select("-password")
        .limit(10);
    }

    if (type === "all" || type === "campaigns") {
      results.campaigns = await Campaign.find({
        $or: [
          { title: { $regex: q, $options: "i" } },
          { urls: { $regex: q, $options: "i" } },
          { spark_traffic_project_id: { $regex: q, $options: "i" } },
        ],
      })
        .populate("user", "email firstName lastName")
        .limit(10);
    }

    res.json({
      ok: true,
      query: q,
      results,
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Archive Management
router.get("/archives/stats", requireRole("admin"), async (req, res) => {
  try {
    const { getArchiveStats } = require("../utils/archiveCleanup");
    const stats = await getArchiveStats();

    res.json({
      ok: true,
      archiveStats: stats,
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Run cleanup job manually
router.post("/archives/cleanup", requireRole("admin"), async (req, res) => {
  try {
    const {
      cleanupArchivedCampaigns,
      permanentDeleteEligibleCampaigns,
    } = require("../utils/archiveCleanup");

    const cleanupResult = await cleanupArchivedCampaigns();
    const deleteResult = await permanentDeleteEligibleCampaigns();

    res.json({
      ok: true,
      message: "Cleanup completed",
      results: {
        markedForDeletion: cleanupResult?.modifiedCount || 0,
        permanentlyDeleted: deleteResult || 0,
      },
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Get all archived campaigns
router.get("/archives/campaigns", requireRole("admin"), async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 20;
    const skip = (page - 1) * limit;

    const [archivedCampaigns, totalArchived] = await Promise.all([
      Campaign.find({ is_archived: true })
        .populate("user", "email firstName lastName")
        .sort({ archived_at: -1 })
        .skip(skip)
        .limit(limit),
      Campaign.countDocuments({ is_archived: true }),
    ]);

    res.json({
      ok: true,
      campaigns: archivedCampaigns,
      pagination: {
        currentPage: page,
        totalPages: Math.ceil(totalArchived / limit),
        totalCampaigns: totalArchived,
        hasNext: page * limit < totalArchived,
        hasPrev: page > 1,
      },
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// REMOVED: Fix user hits endpoint - No longer needed with subscription-based system

// Get transfer history for a campaign
router.get(
  "/campaigns/:campaignId/transfer-history",
  requireRole("admin"),
  async (req, res) => {
    try {
      const { campaignId } = req.params;

      const campaign = await Campaign.findById(campaignId)
        .select("title spark_traffic_project_id transfer_history user")
        .populate("user", "email firstName lastName");

      if (!campaign) {
        return res.status(404).json({
          status: "error",
          message: "Campaign not found",
        });
      }

      if (!campaign.spark_traffic_project_id) {
        return res.status(400).json({
          status: "error",
          message: "Only Alpha campaigns have transfer history",
        });
      }

      // Populate transfer history with user details
      const transferHistory = [];
      if (campaign.transfer_history && campaign.transfer_history.length > 0) {
        for (const transfer of campaign.transfer_history) {
          const [fromUser, toUser, adminUser] = await Promise.all([
            User.findById(transfer.from_user).select(
              "email firstName lastName"
            ),
            User.findById(transfer.to_user).select("email firstName lastName"),
            User.findById(transfer.transferred_by).select(
              "email firstName lastName"
            ),
          ]);

          transferHistory.push({
            from: fromUser
              ? {
                  id: fromUser._id,
                  email: fromUser.email,
                  name: `${fromUser.firstName} ${fromUser.lastName}`.trim(),
                }
              : {
                  id: transfer.from_user,
                  email: "User not found",
                  name: "Unknown",
                },
            to: toUser
              ? {
                  id: toUser._id,
                  email: toUser.email,
                  name: `${toUser.firstName} ${toUser.lastName}`.trim(),
                }
              : {
                  id: transfer.to_user,
                  email: "User not found",
                  name: "Unknown",
                },
            transferredBy: adminUser
              ? {
                  id: adminUser._id,
                  email: adminUser.email,
                  name: `${adminUser.firstName} ${adminUser.lastName}`.trim(),
                }
              : {
                  id: transfer.transferred_by,
                  email: "Admin not found",
                  name: "Unknown",
                },
            transferredAt: transfer.transferred_at,
            reason: transfer.reason || "No reason provided",
          });
        }
      }

      res.json({
        status: "success",
        campaign: {
          id: campaign._id,
          title: campaign.title,
          sparkTrafficProjectId: campaign.spark_traffic_project_id,
          currentOwner: {
            id: campaign.user._id,
            email: campaign.user.email,
            name: `${campaign.user.firstName} ${campaign.user.lastName}`.trim(),
          },
        },
        transferHistory: transferHistory,
      });
    } catch (error) {
      console.error("Error fetching transfer history:", error);
      res.status(500).json({
        status: "error",
        message: "Internal server error",
        error: error.message,
      });
    }
  }
);

// Get all Alpha campaigns for transfer management
router.get(
  "/campaigns/alpha/transferable",
  requireRole("admin"),
  async (req, res) => {
    try {
      const page = parseInt(req.query.page) || 1;
      const limit = parseInt(req.query.limit) || 20;
      const skip = (page - 1) * limit;

      // Find all Alpha campaigns
      const [campaigns, totalCampaigns] = await Promise.all([
        Campaign.find({
          spark_traffic_project_id: { $exists: true, $ne: null },
        })
          .populate("user", "email firstName lastName")
          .sort({ createdAt: -1 })
          .skip(skip)
          .limit(limit),
        Campaign.countDocuments({
          spark_traffic_project_id: { $exists: true, $ne: null },
        }),
      ]);

      // Add transfer count to each campaign
      const campaignsWithTransferInfo = campaigns.map((campaign) => ({
        ...campaign.toObject(),
        transferCount: campaign.transfer_history
          ? campaign.transfer_history.length
          : 0,
        lastTransfer:
          campaign.transfer_history && campaign.transfer_history.length > 0
            ? campaign.transfer_history[campaign.transfer_history.length - 1]
                .transferred_at
            : null,
      }));

      res.json({
        status: "success",
        campaigns: campaignsWithTransferInfo,
        pagination: {
          currentPage: page,
          totalPages: Math.ceil(totalCampaigns / limit),
          totalCampaigns,
          hasNext: page * limit < totalCampaigns,
          hasPrev: page > 1,
        },
      });
    } catch (error) {
      console.error("Error fetching transferable campaigns:", error);
      res.status(500).json({
        status: "error",
        message: "Internal server error",
        error: error.message,
      });
    }
  }
);

// ============================================================
// SUBSCRIPTION MANAGEMENT BY ADMIN
// ============================================================

// Assign or Update User Subscription
router.post(
  "/users/:userId/subscription",
  requireRole("admin"),
  async (req, res) => {
    try {
      const { userId } = req.params;
      const { planName, reason } = req.body;

      // Validate plan name
      const validPlans = ["free", "starter", "growth", "business", "premium", "custom"];
      if (!planName || !validPlans.includes(planName)) {
        return res.status(400).json({
          error: "Invalid plan name",
          validPlans: validPlans,
          received: planName,
        });
      }

      // Find user
      const user = await User.findById(userId).select("-password");
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }

      // Get plan configuration
      const Subscription = require("../models/Subscription");
      const planConfig = Subscription.getPlanConfig(planName);

      // Find or create subscription
      let subscription = await Subscription.findOne({ user: userId });
      const isNewSubscription = !subscription;

      if (!subscription) {
        // Create new subscription
        subscription = new Subscription({
          user: userId,
          stripeCustomerId: user.stripeCustomerId || `admin_assigned_${userId}`,
          planName: planName,
          status: "active",
          visitsIncluded: planConfig.visitsIncluded,
          campaignLimit: planConfig.campaignLimit,
          visitsUsed: 0,
          features: planConfig.features,
          currentPeriodStart: new Date(),
          currentPeriodEnd: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000), // 1 year
          adminAssigned: true,
          assignedBy: req.user.id,
          assignedAt: new Date(),
          assignmentReason: reason || "Admin assignment",
        });
      } else {
        // Update existing subscription
        const oldPlan = subscription.planName;

        subscription.planName = planName;
        subscription.status = "active";
        subscription.visitsIncluded = planConfig.visitsIncluded;
        subscription.campaignLimit = planConfig.campaignLimit;
        subscription.features = planConfig.features;
        subscription.adminAssigned = true;
        subscription.lastModifiedBy = req.user.id;
        subscription.lastModifiedAt = new Date();
        subscription.modificationReason =
          reason || `Admin changed plan from ${oldPlan} to ${planName}`;

        // Reset period if switching plans
        subscription.currentPeriodStart = new Date();
        subscription.currentPeriodEnd = new Date(
          Date.now() + 365 * 24 * 60 * 60 * 1000
        );

        // Optionally reset visits for new period (keep this if you want to reset on plan change)
        // subscription.visitsUsed = 0;
      }

      await subscription.save();

      // Count current campaigns
      const Campaign = require("../models/Campaign");
      const currentCampaigns = await Campaign.countDocuments({
        user: userId,
        $or: [{ is_archived: { $exists: false } }, { is_archived: false }],
      });

      res.json({
        ok: true,
        message: isNewSubscription
          ? `Subscription assigned successfully to ${user.email}`
          : `Subscription updated successfully for ${user.email}`,
        action: isNewSubscription ? "created" : "updated",
        subscription: {
          planName: subscription.planName,
          status: subscription.status,
          visitsIncluded: subscription.visitsIncluded,
          visitsUsed: subscription.visitsUsed,
          campaignLimit: subscription.campaignLimit,
          currentCampaigns: currentCampaigns,
          features: subscription.features,
          currentPeriodStart: subscription.currentPeriodStart,
          currentPeriodEnd: subscription.currentPeriodEnd,
          adminAssigned: true,
          assignedBy: req.user.email,
          reason:
            reason || (isNewSubscription ? "Admin assignment" : "Admin update"),
        },
        user: {
          id: user._id,
          email: user.email,
          firstName: user.firstName,
          lastName: user.lastName,
        },
      });
    } catch (error) {
      console.error("Error assigning subscription:", error);
      res.status(500).json({
        error: "Failed to assign subscription",
        details: error.message,
      });
    }
  }
);

// Get User's Subscription Details (Admin view)
router.get(
  "/users/:userId/subscription",
  requireRole("admin"),
  async (req, res) => {
    try {
      const { userId } = req.params;

      const user = await User.findById(userId).select("-password");
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }

      const Subscription = require("../models/Subscription");
      const subscription = await Subscription.findOne({ user: userId });

      if (!subscription) {
        return res.json({
          ok: true,
          message: "User has no subscription",
          user: {
            id: user._id,
            email: user.email,
            firstName: user.firstName,
            lastName: user.lastName,
          },
          subscription: null,
          suggestion:
            "Use POST /admin/users/:userId/subscription to assign a plan",
        });
      }

      // Count current campaigns
      const Campaign = require("../models/Campaign");
      const currentCampaigns = await Campaign.countDocuments({
        user: userId,
        $or: [{ is_archived: { $exists: false } }, { is_archived: false }],
      });

      res.json({
        ok: true,
        user: {
          id: user._id,
          email: user.email,
          firstName: user.firstName,
          lastName: user.lastName,
          stripeCustomerId: user.stripeCustomerId,
        },
        subscription: {
          id: subscription._id,
          planName: subscription.planName,
          status: subscription.status,
          visitsIncluded: subscription.visitsIncluded,
          visitsUsed: subscription.visitsUsed,
          campaignLimit: subscription.campaignLimit,
          currentCampaigns: currentCampaigns,
          features: subscription.features,
          currentPeriodStart: subscription.currentPeriodStart,
          currentPeriodEnd: subscription.currentPeriodEnd,
          cancelAtPeriodEnd: subscription.cancelAtPeriodEnd,
          stripeSubscriptionId: subscription.stripeSubscriptionId,
          stripePriceId: subscription.stripePriceId,
          adminAssigned: subscription.adminAssigned || false,
          assignedBy: subscription.assignedBy,
          assignedAt: subscription.assignedAt,
          lastModifiedBy: subscription.lastModifiedBy,
          lastModifiedAt: subscription.lastModifiedAt,
          createdAt: subscription.createdAt,
          updatedAt: subscription.updatedAt,
        },
      });
    } catch (error) {
      console.error("Error fetching subscription:", error);
      res.status(500).json({
        error: "Failed to fetch subscription",
        details: error.message,
      });
    }
  }
);

// Assign Custom Plan to User
router.post(
  "/users/:userId/custom-subscription",
  requireRole("admin"),
  async (req, res) => {
    try {
      const { userId } = req.params;
      const {
        visitsIncluded,
        campaignLimit,
        price,
        description,
        reason,
        features,
        durationDays,
      } = req.body;

      // Validate required fields
      if (
        visitsIncluded === undefined ||
        campaignLimit === undefined ||
        price === undefined
      ) {
        return res.status(400).json({
          error: "Missing required fields",
          required: ["visitsIncluded", "campaignLimit", "price"],
          received: { visitsIncluded, campaignLimit, price },
        });
      }

      // Validate values
      if (
        visitsIncluded < 0 ||
        campaignLimit < 0 ||
        price < 0 ||
        !Number.isInteger(visitsIncluded) ||
        !Number.isInteger(campaignLimit)
      ) {
        return res.status(400).json({
          error: "Invalid values",
          details:
            "visitsIncluded and campaignLimit must be positive integers, price must be positive",
        });
      }

      // Find user
      const user = await User.findById(userId).select("-password");
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }

      const Subscription = require("../models/Subscription");

      // Get default custom plan config
      const defaultCustomConfig = Subscription.getPlanConfig("custom");

      // Merge provided features with defaults
      const customFeatures = {
        ...defaultCustomConfig.features,
        ...(features || {}),
      };

      // Find or create subscription
      let subscription = await Subscription.findOne({ user: userId });
      const isNewSubscription = !subscription;

      const duration = durationDays || 365; // Default 1 year

      if (!subscription) {
        // Create new subscription with custom plan
        subscription = new Subscription({
          user: userId,
          stripeCustomerId:
            user.stripeCustomerId || `admin_custom_${userId}`,
          planName: "custom",
          status: "active",
          visitsIncluded: visitsIncluded,
          campaignLimit: campaignLimit,
          visitsUsed: 0,
          features: customFeatures,
          currentPeriodStart: new Date(),
          currentPeriodEnd: new Date(
            Date.now() + duration * 24 * 60 * 60 * 1000
          ),
          customPlanDetails: {
            price: price,
            description:
              description || `Custom plan for ${user.email}`,
            customFeatures: features || {},
          },
          adminAssigned: true,
          assignedBy: req.user.id,
          assignedAt: new Date(),
          assignmentReason:
            reason || "Admin assigned custom plan",
        });
      } else {
        // Update existing subscription to custom plan
        const oldPlan = subscription.planName;

        subscription.planName = "custom";
        subscription.status = "active";
        subscription.visitsIncluded = visitsIncluded;
        subscription.campaignLimit = campaignLimit;
        subscription.features = customFeatures;
        subscription.customPlanDetails = {
          price: price,
          description:
            description || `Custom plan for ${user.email}`,
          customFeatures: features || {},
        };
        subscription.adminAssigned = true;
        subscription.lastModifiedBy = req.user.id;
        subscription.lastModifiedAt = new Date();
        subscription.modificationReason =
          reason ||
          `Admin changed plan from ${oldPlan} to custom plan`;

        // Reset period
        subscription.currentPeriodStart = new Date();
        subscription.currentPeriodEnd = new Date(
          Date.now() + duration * 24 * 60 * 60 * 1000
        );
      }

      await subscription.save();

      // Count current campaigns
      const Campaign = require("../models/Campaign");
      const currentCampaigns = await Campaign.countDocuments({
        user: userId,
        $or: [{ is_archived: { $exists: false } }, { is_archived: false }],
      });

      res.json({
        ok: true,
        message: isNewSubscription
          ? `Custom subscription assigned successfully to ${user.email}`
          : `Subscription updated to custom plan for ${user.email}`,
        action: isNewSubscription ? "created" : "updated",
        subscription: {
          planName: subscription.planName,
          status: subscription.status,
          visitsIncluded: subscription.visitsIncluded,
          visitsUsed: subscription.visitsUsed,
          campaignLimit: subscription.campaignLimit,
          currentCampaigns: currentCampaigns,
          features: subscription.features,
          currentPeriodStart: subscription.currentPeriodStart,
          currentPeriodEnd: subscription.currentPeriodEnd,
          customPlanDetails: subscription.customPlanDetails,
          adminAssigned: true,
          assignedBy: req.user.email,
          reason:
            reason ||
            (isNewSubscription
              ? "Admin assigned custom plan"
              : "Admin updated to custom plan"),
        },
        user: {
          id: user._id,
          email: user.email,
          firstName: user.firstName,
          lastName: user.lastName,
        },
      });
    } catch (error) {
      console.error("Error assigning custom subscription:", error);
      res.status(500).json({
        error: "Failed to assign custom subscription",
        details: error.message,
      });
    }
  }
);

// Get All Users with Subscriptions
router.get("/subscriptions", requireRole("admin"), async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 20;
    const skip = (page - 1) * limit;
    const planFilter = req.query.plan; // Filter by plan name

    const Subscription = require("../models/Subscription");
    const Campaign = require("../models/Campaign");

    let filter = {};
    if (planFilter) {
      filter.planName = planFilter;
    }

    const [subscriptions, totalSubscriptions] = await Promise.all([
      Subscription.find(filter)
        .populate("user", "email firstName lastName")
        .sort({ updatedAt: -1 })
        .skip(skip)
        .limit(limit),
      Subscription.countDocuments(filter),
    ]);

    // Get campaign counts for each user
    const subscriptionsWithCampaigns = await Promise.all(
      subscriptions.map(async (sub) => {
        const campaignCount = await Campaign.countDocuments({
          user: sub.user._id,
          $or: [{ is_archived: { $exists: false } }, { is_archived: false }],
        });

        return {
          subscriptionId: sub._id,
          planName: sub.planName,
          status: sub.status,
          visitsIncluded: sub.visitsIncluded,
          visitsUsed: sub.visitsUsed,
          campaignLimit: sub.campaignLimit,
          currentCampaigns: campaignCount,
          adminAssigned: sub.adminAssigned || false,
          currentPeriodStart: sub.currentPeriodStart,
          currentPeriodEnd: sub.currentPeriodEnd,
          cancelAtPeriodEnd: sub.cancelAtPeriodEnd,
          user: {
            id: sub.user._id,
            email: sub.user.email,
            name: `${sub.user.firstName} ${sub.user.lastName}`.trim(),
          },
        };
      })
    );

    // Get plan distribution stats
    const planStats = await Subscription.aggregate([
      { $group: { _id: "$planName", count: { $sum: 1 } } },
      { $sort: { _id: 1 } },
    ]);

    res.json({
      ok: true,
      subscriptions: subscriptionsWithCampaigns,
      pagination: {
        currentPage: page,
        totalPages: Math.ceil(totalSubscriptions / limit),
        totalSubscriptions,
        hasNext: page * limit < totalSubscriptions,
        hasPrev: page > 1,
      },
      planDistribution: planStats,
      filter: planFilter ? { plan: planFilter } : null,
    });
  } catch (error) {
    console.error("Error fetching subscriptions:", error);
    res.status(500).json({
      error: "Failed to fetch subscriptions",
      details: error.message,
    });
  }
});

// Delete User's Subscription (Reset to free tier)
router.delete(
  "/users/:userId/subscription",
  requireRole("admin"),
  async (req, res) => {
    try {
      const { userId } = req.params;
      const { reason } = req.body;

      const user = await User.findById(userId).select("-password");
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }

      const Subscription = require("../models/Subscription");
      const subscription = await Subscription.findOne({ user: userId });

      if (!subscription) {
        return res.json({
          ok: true,
          message: "User has no subscription to delete",
          user: {
            email: user.email,
          },
        });
      }

      const oldPlan = subscription.planName;

      // Reset to free plan instead of deleting
      const planConfig = Subscription.getPlanConfig("free");
      subscription.planName = "free";
      subscription.status = "active";
      subscription.visitsIncluded = planConfig.visitsIncluded;
      subscription.campaignLimit = planConfig.campaignLimit;
      subscription.features = planConfig.features;
      subscription.visitsUsed = 0;
      subscription.stripeSubscriptionId = null;
      subscription.stripePriceId = null;
      subscription.adminAssigned = true;
      subscription.lastModifiedBy = req.user.id;
      subscription.lastModifiedAt = new Date();
      subscription.modificationReason =
        reason || `Admin reset from ${oldPlan} to free plan`;

      await subscription.save();

      res.json({
        ok: true,
        message: `Subscription reset to free tier for ${user.email}`,
        previousPlan: oldPlan,
        newPlan: "free",
        subscription: {
          planName: subscription.planName,
          status: subscription.status,
          visitsIncluded: subscription.visitsIncluded,
          campaignLimit: subscription.campaignLimit,
          features: subscription.features,
        },
        user: {
          id: user._id,
          email: user.email,
        },
      });
    } catch (error) {
      console.error("Error resetting subscription:", error);
      res.status(500).json({
        error: "Failed to reset subscription",
        details: error.message,
      });
    }
  }
);

module.exports = router;
